'use strict';

const net = require('net');
const async = require('../../lib/async');
const transport = require('../../lib/transport');
const packer = require('./packer');
const delivery = require('./delivery');
const gn = require('../gracenode');

const PORT_IN_USE = 'EADDRINUSE';
const ENC = 'binary';

const info = {
	host: '',
	address: '',
	port: 0,
	family: ''
};
const connMap = {};
const buff = {};
var conf = {
	// enable: false,
	address: '127.0.0.1',
	port: 8000,
	relayLimit: 10
};
var logger;
var server;
var onDelivery;
var callbacks = {};

module.exports.config = function (_conf) {
	if (_conf.enable) {
		conf.enable = _conf.enable;
	}
	if (_conf.address) {
		conf.address = _conf.address;
	}
	if (_conf.port) {
		conf.port = _conf.port;
	}
	if (_conf.relayLimit) {
		conf.relayLimit = _conf.relayLimit;
	}
	logger = gn.log.create('portal.delivery:tcp');
};

module.exports.setup = function (cb) {
	gn.onExit(function PortalTCPShutdown(next) {
		try {
			server.close();
			next();
		} catch (error) {
			logger.error('failed to shut down:', error);
			next(error);
		}
	});
	startServer(cb);
};

module.exports.info = function () {
	return info;
};

module.exports.send = function (addr, port, dataBytes, cb) {
	const key = addr + '/' + port;
	const cid = gn.lib.uuid.v4().toString();
	if (!connMap[key]) {
		const client = net.Socket();
		client.connect(port, addr, function (error) {
			if (error) {
				return cb(error);
			}
			connMap[key] = client;
			try {
				connMap[key].write(transport.createRequest(0, 0, dataBytes), ENC);
			} catch (err) {
				logger.error('Failed to send internal command:', err);
				connMap[key].close();
				delete connMap[key];
			}
			if (typeof cb === 'function') {
				callbacks[cid] = cb;
			}
		});
		return;
	}
	try {
		connMap[key].write(transport.createRequest(0, 0, dataBytes), ENC);
	} catch (err) {
		logger.error('failed to send:', err);
		connMap[key].close();
		delete connMap[key];
	}
	if (typeof cb === 'function') {
		callbacks[cid] = cb;
	}
}

module.exports.onDelivery = function (func) {
	onDelivery = func;
};

function startServer(cb) {
	server = net.createServer(handleConnection);
	server.on('listening', function () {
		handleListening();
		// ready
		logger.info('server started @', conf.address, conf.port);
		timedSend();
		cb();
	});
	server.on('error', function (error) {
		if (error && error.code === PORT_IN_USE) {
			logger.verbose('Port is in use:', conf.port);
			conf.port += 1;
			startServer(cb);
			return;
		}
		logger.error('failed to start server @', conf.address, conf.port, error);
		cb(error);
	});
	server.listen({
		port: conf.port,
		host: conf.address,
		exclusive: true
	});
}

function handleListening() {
	const connInfo = server.address();
	if (connInfo) {
		info.address = connInfo.address;
		info.host = conf.address;
		info.port = connInfo.port;
		info.family = connInfo.family;
	}
}

function handleConnection(sock) {
	logger.debug('new mesh node connected', sock.remoteAddress, sock.remotePort);
	const conn = new Connection(sock);
}

function Connection(sock) {
	const that = this;
	this.sock = sock;
	this.stream = new transport.Stream();
	this.sock.on('data', function (data) {
		that.handleData(data);
	});
	this.sock.on('end', function () {
		that.handleEnd();
	});
	this.sock.on('close', function () {
		that.handleClose();
	});
	this.sock.on('error', function (error) {
		that.handleError(error);
	});
}

Connection.prototype.handleData = function (buf) {
	this.stream.lazyParse(buf, function (error, parsed) {
		if (error) {
			return logger.error('failed to stream:', error);
		}
		for (var i = 0, len = parsed.length; i < len; i++) {
			const uncomp = gn.mod.packer.uncompress(parsed[i].payload);
			if (!uncomp) {
				const unpacked = packer.unpack(delivery.DSCHEMA, parsed[i].payload);
				onDelivery(unpacked);
				continue;
			}
			for (var j = 0, jen = uncomp.length; j < jen; j++) {
				const unpacked = packer.unpack(delivery.DSCHEMA, uncomp[j]);
				onDelivery(unpacked);
			}
		}
	});
};

Connection.prototype.handleEnd = function () {
	logger.info(this.sock.remoteAddress, this.sock.remotePort, 'closed connection');
};

Connection.prototype.handleClose = function () {
	logger.info('closing connection to', this.sock.remoteAddress, this.sock.remotePort);
	this.sock.end();
};

Connection.prototype.handleError = function () {
	logger.error(this.sock.remoteAddress, this.sock.remotePort, error);
};
